<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>物理シミュレーションゲーム</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Matter.js の CDN を読み込み -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    // Matter.js のモジュールエイリアス
    const Engine = Matter.Engine,
          Render = Matter.Render,
          Runner = Matter.Runner,
          World = Matter.World,
          Bodies = Matter.Bodies,
          Body = Matter.Body,
          Events = Matter.Events;

    // エンジンとワールドの作成
    const engine = Engine.create();
    const world = engine.world;
    world.gravity.y = 1; // 重力を下方向に設定

    // レンダラーの作成（canvas 全体に描画）
    const render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        width: window.innerWidth,
        height: window.innerHeight,
        wireframes: false,  // 実際の見た目で描画
        background: '#fafafa'
      }
    });
    Render.run(render);

    // ランナーの作成と実行
    const runner = Runner.create();
    Runner.run(runner, engine);

    // 地面（床）の作成
    const ground = Bodies.rectangle(window.innerWidth / 2, window.innerHeight, window.innerWidth, 50, {
      isStatic: true,
      render: { fillStyle: '#060a19' }
    });
    World.add(world, ground);

    // ドラッグ時の状態管理用変数
    let isDragging = false;
    let dragBall = null;
    let startPos = null;
    let currentPos = null;

    // マウスの座標をキャンバス内の座標に変換する補助関数
    function getMousePos(event) {
      const rect = render.canvas.getBoundingClientRect();
      return { x: event.clientX - rect.left, y: event.clientY - rect.top };
    }

    // マウスダウン：クリックした位置に玉を生成
    render.canvas.addEventListener('mousedown', function(event) {
      isDragging = true;
      const pos = getMousePos(event);
      startPos = { x: pos.x, y: pos.y };
      currentPos = { x: pos.x, y: pos.y };

      // 玉（円）の生成：半径20、初期状態は静的にしてドラッグ中に位置が固定される
      dragBall = Bodies.circle(pos.x, pos.y, 20, {
        restitution: 0.8,  // 反発係数（跳ね返り）
        isStatic: true,
        render: { fillStyle: '#FF0000' }
      });
      World.add(world, dragBall);
    });

    // マウスムーブ：ドラッグ中は現在位置を更新
    render.canvas.addEventListener('mousemove', function(event) {
      if (!isDragging) return;
      const pos = getMousePos(event);
      currentPos = { x: pos.x, y: pos.y };
    });

    // マウスアップ：ドラッグ終了→玉を発射する
    render.canvas.addEventListener('mouseup', function(event) {
      if (!isDragging) return;
      isDragging = false;
      const pos = getMousePos(event);
      currentPos = { x: pos.x, y: pos.y };

      // ドラッグの開始位置と終了位置の差から発射する力を計算
      // ※ スリングショットのように、引っ張った方向と反対に発射
      const dx = startPos.x - currentPos.x;
      const dy = startPos.y - currentPos.y;
      const forceMagnitude = 0.005; // 力の倍率（調整可能）

      // 玉を動的な物体に変更して、計算した力を加える
      Body.setStatic(dragBall, false);
      Body.applyForce(dragBall, dragBall.position, { x: dx * forceMagnitude, y: dy * forceMagnitude });

      // 現在のドラッグ対象はリセット（既にワールドには残るので、複数回発射が可能）
      dragBall = null;
      startPos = null;
      currentPos = null;
    });

    // Matter.Render の afterRender イベントで、ドラッグ中の線を描画
    Events.on(render, 'afterRender', function() {
      if (isDragging && dragBall && startPos && currentPos) {
        const context = render.context;
        context.beginPath();
        context.moveTo(startPos.x, startPos.y);
        context.lineTo(currentPos.x, currentPos.y);
        context.strokeStyle = '#0000FF';
        context.lineWidth = 2;
        context.stroke();
      }
    });

    // ウィンドウサイズ変更に対応
    window.addEventListener('resize', function() {
      render.canvas.width = window.innerWidth;
      render.canvas.height = window.innerHeight;
      Render.lookAt(render, {
        min: { x: 0, y: 0 },
        max: { x: window.innerWidth, y: window.innerHeight }
      });
    });
  </script>
</body>
</html>
